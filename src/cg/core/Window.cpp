#include <GL/glew.h>#include <GL/gl.h>#include <GL/glu.h>#include <cstring>#include <map>#include "cg/debug.hpp"#include "cg/core/Window.hpp"/*    WindowManager	========================================= */namespace cg {	namespace core {		class WindowManager {		private:			std::map<u32, Window*> _windows;			SDL_Event _event;						static WindowManager* instance;						static WindowManager* get_instance() {				if (WindowManager::instance == 0) {					WindowManager::instance = new WindowManager();				}				return WindowManager::instance;			}					public:			static void add(u32 window_id, Window* window) {				WindowManager* wm = WindowManager::get_instance();				wm->_windows[window_id] = window;			}						static void update_events() {				WindowManager* wm = WindowManager::get_instance();				Window* window;								while(SDL_PollEvent(&wm->_event)) {					switch(wm->_event.type) {						case SDL_KEYDOWN:							window = wm->_windows[wm->_event.key.windowID];														if (!wm->_event.key.repeat) {								window->_key_down[wm->_event.key.keysym.scancode] = true;							}														window->_key_press[wm->_event.key.keysym.scancode] = true;							break;												case SDL_KEYUP:							window = wm->_windows[wm->_event.key.windowID];														if (!wm->_event.key.repeat) {								window->_key_up[wm->_event.key.keysym.scancode] = true;							}														window->_key_press[wm->_event.key.keysym.scancode] = false;							break;												case SDL_MOUSEMOTION:							window = wm->_windows[wm->_event.motion.windowID];														window->_mouse.pos.x = wm->_event.motion.x;							window->_mouse.pos.y = wm->_event.motion.y;														window->_mouse.rel.x = wm->_event.motion.xrel;							window->_mouse.rel.y = wm->_event.motion.yrel;							break;												case SDL_MOUSEBUTTONDOWN:							window = wm->_windows[wm->_event.button.windowID];														window->_mouse.btn_down[wm->_event.button.button - 1] = true;							window->_mouse.btn_press[wm->_event.button.button - 1] = true;							break;												case SDL_MOUSEBUTTONUP:							window = wm->_windows[wm->_event.button.windowID];														window->_mouse.btn_press[wm->_event.button.button - 1] = false;							window->_mouse.btn_up[wm->_event.button.button - 1] = true;							break;												case SDL_MOUSEWHEEL: {							window = wm->_windows[wm->_event.wheel.windowID];														i32 flipped = 1;														if (wm->_event.wheel.direction == SDL_MOUSEWHEEL_FLIPPED) {								flipped = -1;							}														window->_mouse.wheel.x = wm->_event.wheel.x;							window->_mouse.wheel.y = wm->_event.wheel.y;														break;						}												case SDL_WINDOWEVENT:							window = wm->_windows[wm->_event.window.windowID];														switch(wm->_event.window.event) {								case SDL_WINDOWEVENT_CLOSE:									window->_closed = true;									break;							}					}				}			}		};		WindowManager* WindowManager::instance = 0;		/*	Window			========================================= */		Window::Window(std::string title, Vec2<int> res) {			this->size = res;						this->_closed = false;						this->_key_up = new bool[322];			this->_key_down = new bool[322];			this->_key_press = new bool[322];						this->_mouse.btn_up = new bool[5];			this->_mouse.btn_down = new bool[5];			this->_mouse.btn_press = new bool[5];						std::memset(this->_key_up, 0, 322);			std::memset(this->_key_down, 0, 322);			std::memset(this->_key_press, 0, 322);						std::memset(this->_mouse.btn_up, 0, 5);			std::memset(this->_mouse.btn_down, 0, 5);			std::memset(this->_mouse.btn_press, 0, 5);						_window = SDL_CreateWindow(				title.c_str(),				SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,				res.x, res.y, SDL_WINDOW_OPENGL			);						this->_window_id = SDL_GetWindowID(this->_window);			WindowManager::add(this->_window_id, this);						this->_context = SDL_GL_CreateContext(_window);						if (glewInit() != GLEW_OK) {				log("Glew Init ERROR");			}		}		Window::~Window() {			delete[] this->_key_up;			delete[] this->_key_down;			delete[] this->_key_press;						delete[] this->_mouse.btn_up;			delete[] this->_mouse.btn_down;			delete[] this->_mouse.btn_press;						this->_key_up = nullptr;			this->_key_down = nullptr;			this->_key_press = nullptr;						this->_mouse.btn_up = nullptr;			this->_mouse.btn_down = nullptr;			this->_mouse.btn_press = nullptr;		}		bool Window::update() {			SDL_GL_SwapWindow(this->_window);						this->delta_time = _timer.current();			this->life_time = _lifetimer.current();			this->_timer.restart();						std::memset(this->_key_up, 0, 322);			std::memset(this->_key_down, 0, 322);						this->_mouse.wheel = {0, 0};						std::memset(this->_mouse.btn_up, 0, 5);			std::memset(this->_mouse.btn_down, 0, 5);						WindowManager::update_events();						return !this->_closed;		}		void Window::title(std::string title) {			SDL_SetWindowTitle(_window, title.c_str());		}		int Window::fps() {			return 1 / delta_time;		}		bool Window::key_up(cg::key_code key) {			return this->_key_up[(i32) key];		}		bool Window::key_down(cg::key_code key) {			return this->_key_down[(i32) key];		}		bool Window::key_press(cg::key_code key) {			return this->_key_press[(i32) key];		}		bool Window::mouse_down(Mouse button) {			return this->_mouse.btn_down[(i32) button];		}		bool Window::mouse_press(Mouse button) {			return this->_mouse.btn_press[(i32) button];		}		bool Window::mouse_up(Mouse button) {			return this->_mouse.btn_up[(i32) button];		}		Vec2<i32> Window::mouse_wheel() {			return this->_mouse.wheel;		}		Vec2<i32> Window::mouse_pos() {			return this->_mouse.pos;		}		Vec2<i32> Window::mouse_rel() {			return this->_mouse.rel;		}		void Window::viewport(int x, int y, int width, int height) {			glViewport(x, y, width, height);		}		void Window::clear() {			glViewport(0, 0, this->size.x, this->size.y);						glClearColor(color.x, color.y, color.z, color.w);			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);		}		void Window::depth_test(bool enable) {			if (enable) {				glEnable(GL_DEPTH_TEST);			}			else {				glDisable(GL_DEPTH_TEST);			}		}		void Window::ortho2d() {			glMatrixMode(GL_PROJECTION);			glLoadIdentity();			glOrtho(0, size.x, 0, size.y, -1000, 1000);			glMatrixMode(GL_MODELVIEW);			glLoadIdentity();						glEnable(GL_TEXTURE_2D);		}		void Window::log(std::string msg) {			SDL_Log(msg.c_str());						// deberia imprimir en la ventana y no en la consola		}	}}