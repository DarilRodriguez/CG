#include <GL/glew.h>#include <GL/gl.h>#include <GL/glu.h>#include <cstring>#include <map>#include "cg/debug.hpp"#include "cg/core/Window.hpp"#define STB_IMAGE_STATIC#define STB_IMAGE_IMPLEMENTATION#include <vendor/stb_image.h>/*    WindowManager	========================================= */namespace cg {	namespace core {		class WindowManager {		private:			std::map<u32, Window*> _windows;			SDL_Event _event;						static WindowManager* instance;						static WindowManager* get_instance() {				if (WindowManager::instance == 0) {					WindowManager::instance = new WindowManager();				}				return WindowManager::instance;			}					public:			static void add(u32 window_id, Window* window) {				WindowManager* wm = WindowManager::get_instance();				wm->_windows[window_id] = window;			}						static void update_events() {				WindowManager* wm = WindowManager::get_instance();				Window* window;								while(SDL_PollEvent(&wm->_event)) {					switch(wm->_event.type) {						case SDL_KEYDOWN:							window = wm->_windows[wm->_event.key.windowID];														if (!wm->_event.key.repeat) {								window->_key_down[wm->_event.key.keysym.scancode] = true;							}														window->_key_press[wm->_event.key.keysym.scancode] = true;							break;												case SDL_KEYUP:							window = wm->_windows[wm->_event.key.windowID];														if (!wm->_event.key.repeat) {								window->_key_up[wm->_event.key.keysym.scancode] = true;							}														window->_key_press[wm->_event.key.keysym.scancode] = false;							break;												case SDL_MOUSEMOTION:							window = wm->_windows[wm->_event.motion.windowID];														window->_mouse.pos.x = wm->_event.motion.x;							window->_mouse.pos.y = wm->_event.motion.y;														window->_mouse.rel.x = wm->_event.motion.xrel;							window->_mouse.rel.y = wm->_event.motion.yrel;							break;												case SDL_MOUSEBUTTONDOWN:							window = wm->_windows[wm->_event.button.windowID];														window->_mouse.btn_down[wm->_event.button.button - 1] = true;							window->_mouse.btn_press[wm->_event.button.button - 1] = true;							break;												case SDL_MOUSEBUTTONUP:							window = wm->_windows[wm->_event.button.windowID];														window->_mouse.btn_press[wm->_event.button.button - 1] = false;							window->_mouse.btn_up[wm->_event.button.button - 1] = true;							break;												case SDL_MOUSEWHEEL: {							window = wm->_windows[wm->_event.wheel.windowID];														i32 flipped = 1;														if (wm->_event.wheel.direction == SDL_MOUSEWHEEL_FLIPPED) {								flipped = -1;							}														window->_mouse.wheel.x = wm->_event.wheel.x;							window->_mouse.wheel.y = wm->_event.wheel.y;														break;						}												case SDL_WINDOWEVENT:							window = wm->_windows[wm->_event.window.windowID];														switch(wm->_event.window.event) {								case SDL_WINDOWEVENT_CLOSE:									window->_closed = true;									break;							}					}				}			}		};		WindowManager* WindowManager::instance = 0;		/*	Window			========================================= */		Window::Window(std::string title, Vec2<int> res) {			this->fps_avg = 0;			this->size = res;						this->_closed = false;						this->_key_up = new bool[322];			this->_key_down = new bool[322];			this->_key_press = new bool[322];						this->_mouse.btn_up = new bool[5];			this->_mouse.btn_down = new bool[5];			this->_mouse.btn_press = new bool[5];						std::memset(this->_key_up, 0, 322);			std::memset(this->_key_down, 0, 322);			std::memset(this->_key_press, 0, 322);						std::memset(this->_mouse.btn_up, 0, 5);			std::memset(this->_mouse.btn_down, 0, 5);			std::memset(this->_mouse.btn_press, 0, 5);						SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);			SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 1);						SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);			SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);						_window = SDL_CreateWindow(				title.c_str(),				SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,				res.x, res.y, SDL_WINDOW_OPENGL			);						this->_window_id = SDL_GetWindowID(this->_window);			WindowManager::add(this->_window_id, this);						this->_context = SDL_GL_CreateContext(_window);						SDL_GL_SetSwapInterval(1); // v-sync			SDL_GL_SetSwapInterval(0); // v-sync						if (glewInit() != GLEW_OK) {				log("Glew Init ERROR");			}		}		Window::~Window() {			delete[] this->_key_up;			delete[] this->_key_down;			delete[] this->_key_press;						delete[] this->_mouse.btn_up;			delete[] this->_mouse.btn_down;			delete[] this->_mouse.btn_press;						this->_key_up = nullptr;			this->_key_down = nullptr;			this->_key_press = nullptr;						this->_mouse.btn_up = nullptr;			this->_mouse.btn_down = nullptr;			this->_mouse.btn_press = nullptr;		}		bool Window::update() {			SDL_GL_SwapWindow(this->_window);						this->delta_time = _timer.current();			this->life_time = _lifetimer.current();			this->_timer.restart();						std::memset(this->_key_up, 0, 322);			std::memset(this->_key_down, 0, 322);						this->_mouse.wheel = {0, 0};						std::memset(this->_mouse.btn_up, 0, 5);			std::memset(this->_mouse.btn_down, 0, 5);						WindowManager::update_events();						return !this->_closed;		}		void Window::title(const std::string title) {			SDL_SetWindowTitle(_window, title.c_str());		}		void Window::icon(const std::string icon_path) {			u32 format;			i32 depth, pitch;						i32 w, h, n;			u8 *image = stbi_load(&icon_path[0], &w, &h, &n, 0);						if (image == nullptr) {				cg::log("stbi_load error on load image");				return;			}			else {				cg::log("stbi_load loaded image", icon_path);			}						switch (n) {				case 1: /* format = GL_GRAY; */ break;				case 2: /* format = GL_GRAY; */ break;								case 3:					format = SDL_PIXELFORMAT_RGB24;					depth = 24;					pitch = 3 * w;					break;								case 4:					format = SDL_PIXELFORMAT_RGBA32;					depth = 32;					pitch = 4 * w;					break;			}			SDL_Surface* surf = SDL_CreateRGBSurfaceWithFormatFrom(				(void*)image, w, h,				depth, pitch, format			);			if (surf == NULL) {				cg::log("Creating surface failed: %s", SDL_GetError());				delete image;				exit(1);			}						SDL_SetWindowIcon(_window, surf);						delete image;			SDL_FreeSurface(surf);		}		int Window::fps() {			fps_avg += 1 / delta_time;			fps_count++;						if ((i32) life_time % 1 == 0) {				fps_avg = fps_avg / fps_count;				fps_count = 1;			}						return fps_avg / fps_count;		}		bool Window::key_up(cg::key_code key) {			return this->_key_up[(i32) key];		}		bool Window::key_down(cg::key_code key) {			return this->_key_down[(i32) key];		}		bool Window::key_press(cg::key_code key) {			return this->_key_press[(i32) key];		}		bool Window::mouse_down(Mouse button) {			return this->_mouse.btn_down[(i32) button];		}		bool Window::mouse_press(Mouse button) {			return this->_mouse.btn_press[(i32) button];		}		bool Window::mouse_up(Mouse button) {			return this->_mouse.btn_up[(i32) button];		}		Vec2<i32> Window::mouse_wheel() {			return this->_mouse.wheel;		}		Vec2<i32> Window::mouse_pos() {			return this->_mouse.pos;		}		Vec2<i32> Window::mouse_rel() {			return this->_mouse.rel;		}		void Window::viewport(int x, int y, int width, int height) {			glViewport(x, y, width, height);		}		void Window::clear(bool depth) {			glClearColor(color.x, color.y, color.z, color.w);			if (depth) glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);			else glClear(GL_COLOR_BUFFER_BIT);		}		void Window::depth_test(bool enable) {			if (enable) {				glEnable(GL_DEPTH_TEST);			}			else {				glDisable(GL_DEPTH_TEST);			}		}		void Window::ortho2d() {			glMatrixMode(GL_PROJECTION);			glLoadIdentity();			glOrtho(0, size.x, 0, size.y, -1000, 1000);			glMatrixMode(GL_MODELVIEW);			glLoadIdentity();						glEnable(GL_TEXTURE_2D);		}		void Window::log(std::string msg) {			SDL_Log(msg.c_str());						// deberia imprimir en la ventana y no en la consola		}	}}